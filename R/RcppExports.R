# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculating the log of sum of exponentiation vector
#' @param x a numeric vector
#' @return log(sum(exp(x[1]) + exp(x[2]) + ...))
#' @examples
#' logsumexp(c(1, 2, 3))
#' log(sum(exp(c(1, 2, 3))))
#' @export
logsumexp <- function(x) {
    .Call('_LCVA_logsumexp', PACKAGE = 'LCVA', x)
}

#' Sample from log of unnormalized probability vector
#' @param x a vector of log of unnormalized probability vector
#' @return a sample from 0 to length(x)-1, with probabilities exp(x)/sum(exp(x))
#' @examples
#' x <- rep(0, 10000)
#' prob <- c(1, 2, 3, 4)
#' logprob <- log(prob) 
#' for(i in 1:10000){
#'   x[i] <- sample_log_prob(logprob) 
#' }
#' round(table(x) / 10000, 2)
#' @export
#' 
sample_log_prob <- function(x) {
    .Call('_LCVA_sample_log_prob', PACKAGE = 'LCVA', x)
}

#' Sample from a column of the log of unnormalized probability matrix
#' @param x a matrix where each column contains the log of a unnormalized probability vector
#' @param id column index, starting from 0.
#' @return a sample from 0 to length(x)-1, with probabilities exp(x[, id + 1])/sum(exp(x, id + 1))
#' @examples
#' x <- rep(0, 10000)
#' prob <- cbind(c(1, 2, 3, 4), c(4, 3, 2, 1))
#' logprob <- log(prob) 
#' for(i in 1:10000){
#'   x[i] <- sample_log_prob_matrix_col(logprob, 0) 
#' }
#' table(x) / 10000
#' for(i in 1:10000){
#'   x[i] <- sample_log_prob_matrix_col(logprob, 1) 
#' }
#' round(table(x) / 10000, 2)
#' @export
#' 
sample_log_prob_matrix_col <- function(x, id) {
    .Call('_LCVA_sample_log_prob_matrix_col', PACKAGE = 'LCVA', x, id)
}

#' Sample from log of unnormalized probability matrix
#' @param x a matrix where each cell contains the log of a unnormalized probability matrix.
#' @return the row and column index of a sample of the cells in the matrix. Index starting from 0.
#' @examples
#' x <- matrix(0, 10000, 2)
#' prob <- cbind(c(1, 2, 3, 4), c(4, 3, 2, 1))
#' logprob <- log(prob) 
#' for(i in 1:10000){
#'   x[i, ] <- sample_log_prob_matrix(logprob) 
#' }
#' round(table(paste(x[, 1], x[, 2], sep = "-")) / 10000, 2)
#' prob / sum(prob)
#' @export
#' 
sample_log_prob_matrix <- function(x) {
    .Call('_LCVA_sample_log_prob_matrix', PACKAGE = 'LCVA', x)
}

#' Sample from a probability vector
#' @param x a vector of a probability vector
#' @return a sample from 0 to length(x)-1, with probabilities x / sum(x).
#' @examples
#' x <- rep(0, 10000)
#' prob <- c(.1, .2, .3, .4)
#' for(i in 1:10000){
#'   x[i] <- sample_prob(prob) 
#' }
#' round(table(x) / 10000, 2)
#' @export
#' 
sample_prob <- function(x) {
    .Call('_LCVA_sample_prob', PACKAGE = 'LCVA', x)
}

#' Sample from the Dirichlet distribution
#'
#' @param a vector of Dirichlet concentration parameter
#' @return a sample from Dirichlet(a).  
#' @examples
#' alpha <- c(1, 2, 3, 4)
#' x <- matrix(0, 10000, 4)
#' for(i in 1:10000){
#'   x[i, ] <- sample_Dirichlet(alpha) 
#' }
#' round(apply(x, 2, mean), 2)
#' @export
#' 
sample_Dirichlet <- function(a) {
    .Call('_LCVA_sample_Dirichlet', PACKAGE = 'LCVA', a)
}

#' Internal function to fit the nested latent class model on training data
#' 
#' @param X a n by p matrix of the symptoms with 0 being absent, 1 being present, and NA being missing.
#' @param Y a vector of length n of the causes-of-death, coded into 1 to C, where C is the total number of all cause.
#' @param Group a vector of length n of the domain indicators, coded into 1 to G, where G is the total number of all domains.
#' @param X_test currently not used.
#' @param Y_test currently not used.
#' @param Group_test currently not used.
#' @param N_train size of training data, n. 
#' @param N_test currently not used.
#' @param S number of symptoms.
#' @param C number of causes.
#' @param K number of latent classes within each cause-of-death.
#' @param G number of training domains.
#' @param alpha_pi Concentration parameter for the training domain CSMF prior.  
#' @param alpha_eta currently not used.
#' @param a_omega Shape parameter of the gamma distribution for the omega_c parameter in the stick-breaking prior.
#' @param b_omega Rate parameter of the gamma distribution for the omega_c parameter in the stick-breaking prior.
#' @param nu_phi Shape2 parameter of the beta distribution for the class-dependent response probabilities.
#' @param nu_tau Shape2 parameter of the sparsity level in the response probabilities.
#' @param a_gamma Shape1 parameter of the gamma prior for the baseline response probabilities.
#' @param b_gamma Shape2 parameter of the gamma prior for the baseline response probabilities.
#' @param Nitr number of iterations to run in each MCMC chain.
#' @param thin number of draws to sample per one saved.
#' @param similarity shrinkage model for the testing domain mixing weights. Currently not used.
#' @param sparse binary indicator of whether to encourage latent profiles to be sparse
#' 
#' @examples
#' message("See ?LCVA.train")
lcm_fit <- function(X, Y, Group, X_test, Y_test, Group_test, N_train, N_test, S, C, K, G, alpha_pi, alpha_eta, a_omega, b_omega, nu_phi, a_gamma, b_gamma, nu_tau, Nitr, thin, similarity, sparse, verbose) {
    .Call('_LCVA_lcm_fit', PACKAGE = 'LCVA', X, Y, Group, X_test, Y_test, Group_test, N_train, N_test, S, C, K, G, alpha_pi, alpha_eta, a_omega, b_omega, nu_phi, a_gamma, b_gamma, nu_tau, Nitr, thin, similarity, sparse, verbose)
}

#' Internal function to predict with the nested latent class model
#' 
#' @param X_test a n by p matrix of the symptoms with 0 being absent, 1 being present, and NA being missing.
#' @param Y_test a vector of length n of the causes-of-death, coded into 0 to C, where C is the total number of all cause and 0 indicates unknown cause of death.  
#' @param Group_test a vector of length n of the domain indicators, coded into 0 to G, where G is the total number of all domains and 0 indicates a new target domain. 
#' @param config_train a matrix of counts for all domain-cause combinations.
#' @param N_test number of deaths to assign a cause to.
#' @param S number of symptoms.
#' @param C number of causes.
#' @param K number of latent classes within each cause-of-death.
#' @param G number of training domains.
#' @param itr_draws vector of iteration indices to use from the training posterior draws.
#' @param alpha_pi_vec vector of the concentration parameters for the target domain CSMF.
#' @param alpha_eta  concentration parameter for the domain or domain-cause mixture prior. Only used for multi-domain models. 
#' @param a_omega Shape parameter of the gamma distribution for the omega_c parameter in the stick-breaking prior.  
#' @param b_omega Rate parameter of the gamma distribution for the omega_c parameter in the stick-breaking prior. 
#' @param lambda_fit posterior draws of the training mix weights.
#' @param phi_fit posterior draws of the response probabilities.
#' @param pi_fit posterior draws of the training CSMF.
#' @param pi_init initial values of the target CSMF.
#' @param Nitr number of iterations to run in each MCMC chain.
#' @param similarity shrinkage model for the testing domain mixing weights. Currently not used.
#' 
#' @examples
#' message("See ?LCVA.pred")
lcm_pred <- function(X_test, Y_test, Group_test, config_train, N_test, S, C, K, G, itr_draws, alpha_pi_vec, alpha_eta, a_omega, b_omega, lambda_fit, phi_fit, pi_fit, pi_init, Nitr, similarity, return_x_given_y, verbose) {
    .Call('_LCVA_lcm_pred', PACKAGE = 'LCVA', X_test, Y_test, Group_test, config_train, N_test, S, C, K, G, itr_draws, alpha_pi_vec, alpha_eta, a_omega, b_omega, lambda_fit, phi_fit, pi_fit, pi_init, Nitr, similarity, return_x_given_y, verbose)
}

